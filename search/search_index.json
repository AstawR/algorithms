{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"arrays/","text":"Arrays Definition __ An array is a container that allows you to store multiple values in a single variable. Each value is referred to as an 'element' and can be called when needed by either value or index. The difference between arrays and lists is that arrays are restricted to a fixed size at the time of declaration, they can also only store elements of a single data type, whether that be floating-point numbers, characters, etc. Although lists are the preferred data structure for Python, there are a several built-in methods for arrays in C#. Built-in Methods __ Length: int[] numbers = {1, 2, 3, 4, 5}; int length = numbers.Length; # length = 5. GetValue(int index): int[] numbers = {1, 2, 3, 4, 5}; int value = (int)numbers.GetValue(2); # value = 3. SetValue(object value, int index): int[] numbers = {1, 2, 3, 4, 5}; numbers.SetValue(10, 1); # numbers = {1, 10, 3, 4, 5}. Array.Sort(Array array): int[] numbers = {5, 3, 1, 4, 2}; Array.Sort(numbers); # numbers = {1, 2, 3, 4, 5}.","title":"Arrays"},{"location":"arrays/#arrays","text":"","title":"Arrays"},{"location":"arrays/#_1","text":"","title":""},{"location":"arrays/#definition","text":"__ An array is a container that allows you to store multiple values in a single variable. Each value is referred to as an 'element' and can be called when needed by either value or index. The difference between arrays and lists is that arrays are restricted to a fixed size at the time of declaration, they can also only store elements of a single data type, whether that be floating-point numbers, characters, etc. Although lists are the preferred data structure for Python, there are a several built-in methods for arrays in C#.","title":"Definition"},{"location":"arrays/#_2","text":"","title":""},{"location":"arrays/#built-in-methods","text":"__","title":"Built-in Methods"},{"location":"arrays/#_3","text":"Length: int[] numbers = {1, 2, 3, 4, 5}; int length = numbers.Length; # length = 5. GetValue(int index): int[] numbers = {1, 2, 3, 4, 5}; int value = (int)numbers.GetValue(2); # value = 3. SetValue(object value, int index): int[] numbers = {1, 2, 3, 4, 5}; numbers.SetValue(10, 1); # numbers = {1, 10, 3, 4, 5}. Array.Sort(Array array): int[] numbers = {5, 3, 1, 4, 2}; Array.Sort(numbers); # numbers = {1, 2, 3, 4, 5}.","title":""},{"location":"graphs/","text":"","title":"Graphs"},{"location":"hash%20tables/","text":"","title":"Hash Tables"},{"location":"linked%20lists/","text":"Linked Lists Definition __ A linked list is a linear data structure involving a sequence of what are called 'nodes', each node contains a stored value and a reference to the next node in the sequence. Linked lists are more efficient than lists or arrays when it comes to the insertion and deletion of elements as they don't require reorganisation. Example __ Implementation: class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def append(self, value): new_node = Node(value) if self.head is None: self.head = new_node else: current = self.head while current.next is not None: current = current.next current.next = new_node def display(self): elements = [] current = self.head while current is not None: elements.append(current.value) current = current.next print(elements) Usage: my_list = LinkedList() # Creates a linked list instance. my_list.append(10) # Append elements to the linked list. my_list.append(20) my_list.append(30) my_list.append(40) my_list.display() # Output: [10, 20, 30, 40].","title":"Linked Lists"},{"location":"linked%20lists/#linked-lists","text":"","title":"Linked Lists"},{"location":"linked%20lists/#_1","text":"","title":""},{"location":"linked%20lists/#definition","text":"__ A linked list is a linear data structure involving a sequence of what are called 'nodes', each node contains a stored value and a reference to the next node in the sequence. Linked lists are more efficient than lists or arrays when it comes to the insertion and deletion of elements as they don't require reorganisation.","title":"Definition"},{"location":"linked%20lists/#_2","text":"","title":""},{"location":"linked%20lists/#example","text":"__","title":"Example"},{"location":"linked%20lists/#_3","text":"Implementation: class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def append(self, value): new_node = Node(value) if self.head is None: self.head = new_node else: current = self.head while current.next is not None: current = current.next current.next = new_node def display(self): elements = [] current = self.head while current is not None: elements.append(current.value) current = current.next print(elements) Usage: my_list = LinkedList() # Creates a linked list instance. my_list.append(10) # Append elements to the linked list. my_list.append(20) my_list.append(30) my_list.append(40) my_list.display() # Output: [10, 20, 30, 40].","title":""},{"location":"lists/","text":"Lists Definition __ A list is a collection of values stored behind a variable. Each value is referred to as an 'element' and can be called when needed by either value or index. A single list can contain multiple data types, including strings, integers and bools. Built-in methods are used to add and remove elements from a list: .append(X) - adds X to the end of the list. .insert(Y, X) - inserts X into the list at the Y position. .remove(X) - removes the specified X value from the list. .pop(Y) - removes element at Y position. Examples __ Creating a List: num_list = [2, 3, 6, 8, 10] # list of integers. word_list = [\"Red\", \"Painting\", \"Misc\", \"Jack\"] # list of strings. _list = [2, \"Red\", False, 12.34] # list of various data types. Referencing a List: print(num_list[0]) # prints 2. print(word_list[3]) # prints \"Jack\". print(_list[2]) # prints False. Modifying a List: word_list[2] = \"Miscellaneous\" print(word_list) # prints [\"Red\", \"Painting\", \"Miscellanous\", \"Jack\"]. Adding and Removing Elements: num_list.append(12) print(num_list) # prints [2, 3, 6, 8, 10, 12]. num_list.insert(1, 4) print(num_list) # prints [2, 4, 6, 8, 10, 12]. num_list.remove(10) print(num_list) # prints [2, 4, 6, 8, 12]. num_list.pop(0) print(num_list) # prints [4, 6, 8, 12].","title":"List"},{"location":"lists/#lists","text":"","title":"Lists"},{"location":"lists/#_1","text":"","title":""},{"location":"lists/#definition","text":"__ A list is a collection of values stored behind a variable. Each value is referred to as an 'element' and can be called when needed by either value or index. A single list can contain multiple data types, including strings, integers and bools. Built-in methods are used to add and remove elements from a list: .append(X) - adds X to the end of the list. .insert(Y, X) - inserts X into the list at the Y position. .remove(X) - removes the specified X value from the list. .pop(Y) - removes element at Y position.","title":"Definition"},{"location":"lists/#_2","text":"","title":""},{"location":"lists/#examples","text":"__","title":"Examples"},{"location":"lists/#_3","text":"Creating a List: num_list = [2, 3, 6, 8, 10] # list of integers. word_list = [\"Red\", \"Painting\", \"Misc\", \"Jack\"] # list of strings. _list = [2, \"Red\", False, 12.34] # list of various data types. Referencing a List: print(num_list[0]) # prints 2. print(word_list[3]) # prints \"Jack\". print(_list[2]) # prints False. Modifying a List: word_list[2] = \"Miscellaneous\" print(word_list) # prints [\"Red\", \"Painting\", \"Miscellanous\", \"Jack\"]. Adding and Removing Elements: num_list.append(12) print(num_list) # prints [2, 3, 6, 8, 10, 12]. num_list.insert(1, 4) print(num_list) # prints [2, 4, 6, 8, 10, 12]. num_list.remove(10) print(num_list) # prints [2, 4, 6, 8, 12]. num_list.pop(0) print(num_list) # prints [4, 6, 8, 12].","title":""},{"location":"pyamaze/","text":"Pyamaze Introduction __ You are to create a left-hand wall following algorithm to map the maze and save it as a data structure and then use the mapping you have done to traverse the maze. This involves the robot to only follow the left wall until it has visited all cells and return an array. The array can be a dictionary, 2d array of lists or a combination of both. Once you have created the data structure, create an algorithm to traverse it from the bottom right-hand corner to the top left which is the goal. Save your map structure as a .csv and reload to traverse. Once your algorithm has successfully traversed your saved map, test your mapping and traversing on a 20x20 generated map. Use the tracePath() method and take a screenshot of your successful mapping and traversing. Mapping __ Following The Left Wall To The Goal: from pyamaze import maze, agent import time def RCW(): global direction k=list(direction.keys()) v=list(direction.values()) v_rotated=[v[-1]]+v[:-1] direction=dict(zip(k,v_rotated)) def RCCW(): global direction k=list(direction.keys()) v=list(direction.values()) v_rotated=v[1:]+[v[0]] direction=dict(zip(k,v_rotated)) def moveForward(cell): if direction['forward']=='E': return (cell[0],cell[1]+1), 'E' if direction['forward']=='W': return (cell[0],cell[1]-1), 'W' if direction['forward']=='N': return (cell[0]-1,cell[1]), 'N' if direction['forward']=='S': return (cell[0]+1,cell[1]), 'S' def wallFollower(myMaze): global direction, end direction={'forward': 'N', 'left': 'W', 'back': 'S', 'right': 'E'} currCell=(myMaze.rows,myMaze.cols) path='' dict_path = {} dict_count = 0 end = False while True: if currCell == (1, 1): #ends path before putting goal dict_count += 1 dict_path.update({dict_count: currCell}) currCell, d = moveForward(currCell) path += d break if myMaze.maze_map[currCell][direction['left']]==0: if myMaze.maze_map[currCell][direction['forward']]==0: RCW() else: dict_count += 1 dict_path.update({dict_count: currCell}) currCell,d=moveForward(currCell) path+=d else: RCCW() dict_count += 1 dict_path.update({dict_count: currCell}) currCell,d=moveForward(currCell) path+=d return path, dict_path Tracing The Rest Of The Maze: def wallFollowerSearch(myMaze): global direction direction={'forward': 'N', 'left': 'W', 'back': 'S', 'right': 'E'} currCell=(1, 1) path0='' dict_path2 = {} dict_count = 0 while True: if currCell == (myMaze.rows, myMaze.cols) and direction['forward'] == path[0]: break if myMaze.maze_map[currCell][direction['left']]==0: if myMaze.maze_map[currCell][direction['forward']]==0: RCW() else: currCell,d=moveForward(currCell) path0+=d dict_count += 1 dict_path2.update({dict_count: currCell}) else: RCCW() currCell,d=moveForward(currCell) path0+=d dict_count += 1 dict_path2.update({dict_count: currCell}) pathsearch=path0[1:] return pathsearch, dict_path2 Traversal __ Following the fastest path to the goal: def remove_dead_ends(maze): unique_cells = [] reversed_maze = list(maze.values())[::-1] for cell in reversed_maze: if cell not in unique_cells: unique_cells.append(cell) elif cell in unique_cells: unique_cells = unique_cells[:unique_cells.index(cell) + 1] new_maze = {key: value for key, value in maze.items() if value in unique_cells} return new_maze pathgoal=path while'EW' in pathgoal or 'WE' in pathgoal or 'NS' in pathgoal or 'SN' in pathgoal: pathgoal=pathgoal.replace('EW','') print(pathgoal, \" EW\") pathgoal=pathgoal.replace('WE', '') print(pathgoal, \" WE\") pathgoal=pathgoal.replace('NS', '') print(pathgoal, \" NS\") pathgoal=pathgoal.replace('SN', '') print(pathgoal, \" SN\") Usage __ 20x20 Maze: if __name__=='__main__': start_time = time.time() myMaze=maze() myMaze.CreateMaze() path,dict_path = wallFollower(myMaze) pathsearch, dict_path2 = wallFollowerSearch(myMaze) a = agent(myMaze, shape='arrow', footprints=True) if path[len(path)-2] == 'N': b = agent(myMaze, 2, 1, shape='arrow', footprints=True) else: b = agent(myMaze, 1, 2, shape='arrow', footprints=True) c = agent(myMaze, footprints=True, filled=True) new_maze = remove_dead_ends(dict_path) new_dict = {} seen_values = set() for key, value in new_maze.items(): if value not in seen_values: new_dict[key] = value seen_values.add(value) dict_pathfinal = {} for i, key in enumerate(dict_path.keys()): dict_pathfinal[i + 1] = dict_path[key] start_index = len(dict_path) for i, key in enumerate(dict_path2.keys()): dict_pathfinal[start_index + i + 1] = dict_path2[key] myMaze.tracePath({a: path}) myMaze.tracePath({b: pathsearch}) myMaze.tracePath({c: pathgoal}) print(myMaze.maze_map) print(\"Mapping Path: \", pathsearch) print(\"Mapping Array: \", dict_pathfinal) print(\"Traversal Path: \", pathgoal) print(\"Traversal Array: \", new_dict) myMaze.run() end_time = time.time() execution_time = end_time - start_time print(\"Execution time: \", execution_time, \" seconds\")","title":"PYAMAZE"},{"location":"pyamaze/#pyamaze","text":"","title":"Pyamaze"},{"location":"pyamaze/#_1","text":"","title":""},{"location":"pyamaze/#introduction","text":"__ You are to create a left-hand wall following algorithm to map the maze and save it as a data structure and then use the mapping you have done to traverse the maze. This involves the robot to only follow the left wall until it has visited all cells and return an array. The array can be a dictionary, 2d array of lists or a combination of both. Once you have created the data structure, create an algorithm to traverse it from the bottom right-hand corner to the top left which is the goal. Save your map structure as a .csv and reload to traverse. Once your algorithm has successfully traversed your saved map, test your mapping and traversing on a 20x20 generated map. Use the tracePath() method and take a screenshot of your successful mapping and traversing.","title":"Introduction"},{"location":"pyamaze/#_2","text":"","title":""},{"location":"pyamaze/#mapping","text":"__","title":"Mapping"},{"location":"pyamaze/#_3","text":"Following The Left Wall To The Goal: from pyamaze import maze, agent import time def RCW(): global direction k=list(direction.keys()) v=list(direction.values()) v_rotated=[v[-1]]+v[:-1] direction=dict(zip(k,v_rotated)) def RCCW(): global direction k=list(direction.keys()) v=list(direction.values()) v_rotated=v[1:]+[v[0]] direction=dict(zip(k,v_rotated)) def moveForward(cell): if direction['forward']=='E': return (cell[0],cell[1]+1), 'E' if direction['forward']=='W': return (cell[0],cell[1]-1), 'W' if direction['forward']=='N': return (cell[0]-1,cell[1]), 'N' if direction['forward']=='S': return (cell[0]+1,cell[1]), 'S' def wallFollower(myMaze): global direction, end direction={'forward': 'N', 'left': 'W', 'back': 'S', 'right': 'E'} currCell=(myMaze.rows,myMaze.cols) path='' dict_path = {} dict_count = 0 end = False while True: if currCell == (1, 1): #ends path before putting goal dict_count += 1 dict_path.update({dict_count: currCell}) currCell, d = moveForward(currCell) path += d break if myMaze.maze_map[currCell][direction['left']]==0: if myMaze.maze_map[currCell][direction['forward']]==0: RCW() else: dict_count += 1 dict_path.update({dict_count: currCell}) currCell,d=moveForward(currCell) path+=d else: RCCW() dict_count += 1 dict_path.update({dict_count: currCell}) currCell,d=moveForward(currCell) path+=d return path, dict_path Tracing The Rest Of The Maze: def wallFollowerSearch(myMaze): global direction direction={'forward': 'N', 'left': 'W', 'back': 'S', 'right': 'E'} currCell=(1, 1) path0='' dict_path2 = {} dict_count = 0 while True: if currCell == (myMaze.rows, myMaze.cols) and direction['forward'] == path[0]: break if myMaze.maze_map[currCell][direction['left']]==0: if myMaze.maze_map[currCell][direction['forward']]==0: RCW() else: currCell,d=moveForward(currCell) path0+=d dict_count += 1 dict_path2.update({dict_count: currCell}) else: RCCW() currCell,d=moveForward(currCell) path0+=d dict_count += 1 dict_path2.update({dict_count: currCell}) pathsearch=path0[1:] return pathsearch, dict_path2","title":""},{"location":"pyamaze/#traversal","text":"__","title":"Traversal"},{"location":"pyamaze/#_4","text":"Following the fastest path to the goal: def remove_dead_ends(maze): unique_cells = [] reversed_maze = list(maze.values())[::-1] for cell in reversed_maze: if cell not in unique_cells: unique_cells.append(cell) elif cell in unique_cells: unique_cells = unique_cells[:unique_cells.index(cell) + 1] new_maze = {key: value for key, value in maze.items() if value in unique_cells} return new_maze pathgoal=path while'EW' in pathgoal or 'WE' in pathgoal or 'NS' in pathgoal or 'SN' in pathgoal: pathgoal=pathgoal.replace('EW','') print(pathgoal, \" EW\") pathgoal=pathgoal.replace('WE', '') print(pathgoal, \" WE\") pathgoal=pathgoal.replace('NS', '') print(pathgoal, \" NS\") pathgoal=pathgoal.replace('SN', '') print(pathgoal, \" SN\")","title":""},{"location":"pyamaze/#usage","text":"__","title":"Usage"},{"location":"pyamaze/#_5","text":"20x20 Maze: if __name__=='__main__': start_time = time.time() myMaze=maze() myMaze.CreateMaze() path,dict_path = wallFollower(myMaze) pathsearch, dict_path2 = wallFollowerSearch(myMaze) a = agent(myMaze, shape='arrow', footprints=True) if path[len(path)-2] == 'N': b = agent(myMaze, 2, 1, shape='arrow', footprints=True) else: b = agent(myMaze, 1, 2, shape='arrow', footprints=True) c = agent(myMaze, footprints=True, filled=True) new_maze = remove_dead_ends(dict_path) new_dict = {} seen_values = set() for key, value in new_maze.items(): if value not in seen_values: new_dict[key] = value seen_values.add(value) dict_pathfinal = {} for i, key in enumerate(dict_path.keys()): dict_pathfinal[i + 1] = dict_path[key] start_index = len(dict_path) for i, key in enumerate(dict_path2.keys()): dict_pathfinal[start_index + i + 1] = dict_path2[key] myMaze.tracePath({a: path}) myMaze.tracePath({b: pathsearch}) myMaze.tracePath({c: pathgoal}) print(myMaze.maze_map) print(\"Mapping Path: \", pathsearch) print(\"Mapping Array: \", dict_pathfinal) print(\"Traversal Path: \", pathgoal) print(\"Traversal Array: \", new_dict) myMaze.run() end_time = time.time() execution_time = end_time - start_time print(\"Execution time: \", execution_time, \" seconds\")","title":""},{"location":"queues/","text":"","title":"Queues"},{"location":"sets/","text":"","title":"Sets"},{"location":"stack/","text":"Stack Definition __ A stack is a linear data structure that follows the Last-In-First-Out (LIFO) principle, where a new element added to the top of the stack is the first to be removed. Basic operations/methods when using a stack: push(item) - inserts an item at the top of the stack. pop() - removes the topmost element from the stack. is_empty() - verifies the length of the list, returns true if stack is empty. size() - returns the number of elements in the stack by its length. Example __ Implementation: class Stack: def __init(self): self.stack = [] def push(self, item): self.stack.append(item) def pop(self): if not self.is_empty(): return self.stack.pop() def is_empty(self): return len(self.stack) == 0 def size(self): return len(self.stack) Usage: stack = Stack() stack.push(10) stack.push(20) stack.push(30) print(stack.size()) # prints 3. item = stack.pop() print(item) # prints 30. print(stack.is_empty()) # prints False.","title":"Stack"},{"location":"stack/#stack","text":"","title":"Stack"},{"location":"stack/#_1","text":"","title":""},{"location":"stack/#definition","text":"__ A stack is a linear data structure that follows the Last-In-First-Out (LIFO) principle, where a new element added to the top of the stack is the first to be removed. Basic operations/methods when using a stack: push(item) - inserts an item at the top of the stack. pop() - removes the topmost element from the stack. is_empty() - verifies the length of the list, returns true if stack is empty. size() - returns the number of elements in the stack by its length.","title":"Definition"},{"location":"stack/#_2","text":"","title":""},{"location":"stack/#example","text":"__","title":"Example"},{"location":"stack/#_3","text":"Implementation: class Stack: def __init(self): self.stack = [] def push(self, item): self.stack.append(item) def pop(self): if not self.is_empty(): return self.stack.pop() def is_empty(self): return len(self.stack) == 0 def size(self): return len(self.stack) Usage: stack = Stack() stack.push(10) stack.push(20) stack.push(30) print(stack.size()) # prints 3. item = stack.pop() print(item) # prints 30. print(stack.is_empty()) # prints False.","title":""},{"location":"trees/","text":"","title":"Trees"}]}